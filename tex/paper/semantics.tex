% Semantics

Resources will provide a refinement of the semantics of typed programs.
Thus, we begin with a standard semantics in $\mathrm{Set}$ of typed terms.

\begin{displaymath}
  \begin{array}{c@{\hspace{0.5in}}c}
    \begin{array}{r@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \sem{\base} &=& S_\base \\
      \sem{\excl{\rho}{A}} &=& \sem{A} \\
      \sem{\tensorOne} &=& \{*\} \\
      \sem{\withTOne} &=& \{*\} \\
      \sem{\sumTZero} &=& \{\} \\
    \end{array}
    &
    \begin{array}{r@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \\
      \sem{\fun{A}{B}} &=& \sem{A} \rightarrow \sem{B} \\
      \sem{\tensor{A}{B}} &=& \sem{A} \times \sem{B} \\
      \sem{\withT{A}{B}} &=& \sem{A} \times \sem{B} \\
      \sem{\sumT{A}{B}} &=& \sem{A} \uplus \sem{B} \\
    \end{array}
  \end{array}
\end{displaymath}

The refinement resources provide on top of this is a Kripke-indexed logical
relation $\sem{A}^R : \mathcal{W}^{op} \to \operatorname{Rel}\sem{A}$ for each type $A$.
$\mathcal{W}$ is assumed to be a symmetric promonoidal category.

\begin{displaymath}
  \begin{array}{rlll}
    \sem{\base}^R && &= R_\base \\
    \sem{\fun{A}{B}}^R & w & (f,f') &= \forall x,y.~P(y,w)x \Rightarrow \forall
    a,a'.~\sem{A}^R~y~(a,a') \Rightarrow \sem{B}^R~x~(f~a,f'~a') \\
    \sem{\excl{\rho}{A}}^R & w & (a,a') &= \oc_\rho \sem{A}^R~w~(a,a') \\
    \sem{\tensorOne}^R & w & (*,*) &= Jw \\
    \sem{\tensor{A}{B}}^R & w & ((a,b),(a',b')) &= \exists x,y.~P(x,y)w \wedge
    \sem{A}^R~x~(a,a') \wedge \sem{B}^R~y~(b,b') \\
    \sem{\withTOne}^R & w & (*,*) &= \top \\
    \sem{\withT{A}{B}}^R & w & ((a,b),(a',b')) &=
    \sem{A}^R~w~(a,a') \wedge \sem{B}^R~w~(b,b') \\
    \sem{\sumT{A}{B}}^R & w & (u,u') &=
    \begin{cases}
      \sem{A}^R~w~(a,a') & \text{if } (u,u') = (\operatorname{inl} a,
                           \operatorname{inl} a') \\
      \sem{B}^R~w~(b,b') & \text{if } (u,u') = (\operatorname{inr} b,
                           \operatorname{inr} b') \\
      \bot & \text{otherwise}
    \end{cases}
  \end{array}
\end{displaymath}