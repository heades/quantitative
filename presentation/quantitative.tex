\documentclass{beamer}

\usepackage{booktabs}
\usepackage{subcaption}

\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{amssymb}
\usepackage{cmll}
\usepackage{xcolor}
\usepackage{makecell}
\usepackage{tikz-cd}

\usetikzlibrary{positioning}
%\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows}

\def\newelims{1}
\input{macros}

\title{Context Constrained Computation}
\subtitle{via a linear-like lambda calculus}
\author{Bob Atkey\inst{1} \and James Wood\inst{1}}
\institute{\inst{1}University of Strathclyde}
\date{TyDe Workshop, 2018}

\begin{document}
  \frame{\titlepage}
  \begin{frame}
    \frametitle{Motivation}

    \begin{itemize}
    \item Constrain how variables are used
    \item Derive more free theorems about constrained programs
    \item Generalise the ``how many'' of linear typing \pause
      \begin{itemize}
      \item At what security level? -- information flow \pause
      \item How far away? -- sensitivity analysis \pause
      \item In which direction? -- monotonicity \pause
      \end{itemize}
    \item Formalised in Agda -- the free theorems of the object language are
      available to Agda programs
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Fundamental lemma}
    \begin{itemize}
    \item<1-> Relational parametricity argument
    \item<2-> $\llbracket t \rrbracket : \llbracket \Gamma \rrbracket \to
      \llbracket S \rrbracket$
    \item<3-> $\forall w.~\forall(\alert<4>{\gamma}, \alert<4>{\gamma'}) \in \llbracket \Gamma
      \rrbracket^R~w.~(\alert<4>{\llbracket t \rrbracket~\gamma}, \alert<4>{\llbracket t
      \rrbracket~\gamma'}) \in \llbracket S \rrbracket^R~w$
    \item<5-> Consequences:
      \begin{itemize}
      \item Worlds are bags of keys, semiring counts usages \\
        $\implies$ all functions are permutations
      \item Worlds are distances, semiring tracks distances \\
        $\implies$ all functions are non-expansive
      \item Worlds are trivial, semiring tracks polarity \\
        $\implies$ all functions are monotonic
      \end{itemize}
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Metasyntax}
    \begin{itemize}
    \item Partially ordered semiring: $(R, \leq, 0, +, 1, \cdot)$, general elements $\rho, \pi$ \pause
    \item Contexts
      \begin{itemize}
      \item Scopes $m$, $n$ (natural numbers)
      \item typing contexts $\Gamma = x : S, \ldots, y : T$
      \item resourcing contexts $\Delta = x^\pi, \ldots, y^\rho$ \pause
      \end{itemize}
    \item Bidirectional two-level typing
      \begin{itemize}
      \item Well scoped synthesising terms $e$ and checkable terms $s$
      \item $t$ ranges over $e$ and $s$. \pause
      \item Synthesis: $\typed e : (\Gamma \vdash e \in S)$ \pause
      \item Checking: $\typed s : (\Gamma \vdash S \ni s)$ \pause
      \item Either: $\typed t : (\Gamma \vdash t : S)$ \pause
      \item Resourcing: $\resourced t : (\Delta \vdash \typed t)$ \pause
      \item Abbreviations $\ctx{\Gamma}{\Delta} \vdash e \in S$,
        $\ctx{\Gamma}{\Delta} \vdash S \ni s$, etc.
      \end{itemize}
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Products}
    \begin{align*}
      \textrm{With} && \textrm{Tensor} \\
      \withT{A}{B} && \tensor{A}{B}
    \end{align*}
    \begin{align*}
      \onslide<2->{\mathop{swap_\with} &: \fun{\withT{A}{B}}{\withT{B}{A}}} \\
      \onslide<2->{\mathop{swap_\otimes} &: \fun{\tensor{A}{B}}{\tensor{B}{A}}} \\
      \onslide<3->{\mathop{choose} &: \fun{\withT{A}{A}}{\fun{\mathrm{Bool}}{A}}} \\
      \onslide<4->{\mathop{curry} &: \fun{(\fun{A}{\fun{B}{C}})}{(\fun{\tensor{A}{B}}{C})}}
    \end{align*}
  \end{frame}
  \begin{frame}
    \frametitle{With product}
    \begin{itemize}
    \item Introduction:
      \inferrule{\alert<2>{\ctx{\Gamma}{\Delta}} \vdash S_0 \ni s_0
                 \\ \alert<2>{\ctx{\Gamma}{\Delta}} \vdash S_1 \ni s_1}
                {\alert<2>{\ctx{\Gamma}{\Delta}} \vdash \withT{S_0}{S_1} \ni \wth{s_0}{s_1}}
      \bigskip
    \item Elimination:
      \inferrule{\alert<3>{\ctx{\Gamma}{\Delta}} \vdash e \in \withT{S_0}{S_1}
                 \\ i \in \{0,1\}}
                {\alert<3>{\ctx{\Gamma}{\Delta}} \vdash \proj{i}{e} \in S_i}
      \bigskip
    \item Negative type
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Tensor product}
    \begin{itemize}
    \item Introduction:
      \inferrule{\alert<2>{\ctx{\Gamma}{\Delta_0}} \vdash S_0 \ni s_0
                 \\ \alert<3>{\ctx{\Gamma}{\Delta_1}} \vdash S_1 \ni s_1
                 \\\\ \alert<4>{\rescomment{\Delta \leq \Delta_0 + \Delta_1}}}
                {\alert<4>{\ctx{\Gamma}{\Delta}} \vdash \tensor{S_0}{S_1} \ni \ten{s_0}{s_1}}
      \bigskip
    \item Elimination:
      \inferrule{\alert<5>{\ctx{\Gamma}{\Delta_e}} \vdash e \in \tensor{S_0}{S_1}
                 \\\\ \alert<6>{\ctx{\Gamma}{\Delta_s}},
                      \ctxvar{x}{S_0}{1}, \ctxvar{y}{S_1}{1} \vdash \bind{x,y}{s} \in T
                 \\\\ \alert<7>{\rescomment{\Delta \leq \Delta_e + \Delta_s}}}
                {\alert<7>{\ctx{\Gamma}{\Delta}} \vdash \prm{T}{e}{x}{y}{s} \in T}
      \bigskip
    \item Positive type
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Bang}
    \begin{itemize}
    \item Introduction:
      \inferrule{\ctx{\Gamma}{\Delta_s} \vdash S \ni s
                 \\ \alert<2>{\rescomment{\Delta \leq \rho \cdot \Delta_s}}}
                {\ctx{\Gamma}{\Delta} \vdash \excl{\rho}{S} \ni \bang{s}}
    \item Elimination:
      \inferrule{\ctx{\Gamma}{\Delta_e} \vdash e \in \excl{\rho}{S}
                 \\ \ctx{\Gamma}{\Delta_s}, \ctxvar{x}{S}{\alert<3>{\rho}}
                    \vdash T \ni \bind{x}{s}
                 \\ \rescomment{\Delta \leq \Delta_e + \Delta_s}}
                {\ctx{\Gamma}{\Delta} \vdash \bm{T}{e}{x}{s} \in T}
    \item<4-> Graded comonad:
      \begin{align*}
        \mathop{extract} &: \excl{1}{A} \to A \\
        \mathop{extract} &= \lam{\mathit{ba}}{\emb{\bm{A}{ba}{a}{a}}}
      \end{align*}
      \onslide<5->{
      \begin{align*}
        \mathop{duplicate} &: \excl{\pi \cdot \rho}{A} \to \excl{\pi}{\excl{\rho}{A}} \\
        \mathop{duplicate} &= \lam{\mathit{ba}}{\emb{\bm{\excl{\pi}{\excl{\rho}{A}}}{ba}{a}{\bang{(\bang{\emb{a}})}}}}
      \end{align*}
      }
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Substitution}
    \begin{itemize}
    \item<1-> Well scoped substitution
      \begin{flalign*}
        m \Rightarrow n :\equiv (x \in n) \to \mathrm{Tm}~m~\mathrm{syn}
      \end{flalign*}
    \item<2-> Typed substitution refines scoped substitution
      ($\sigma : m \Rightarrow n$)
      \begin{flalign*}
        \Gamma_m \Rightarrow_\sigma^t \Gamma_n :\equiv
        \left((x : T) \in \Gamma_n\right) \to \Gamma_m \vdash \sigma~x \in T
      \end{flalign*}
    \item<3-> Resourced substitution refines typed substitution
      ($\sigma t : \Gamma_m \Rightarrow_\sigma^t \Gamma_n$)
      \begin{flalign*}
        \Delta_m \Rightarrow_{\typed \sigma}^r \Delta_n :\equiv {}
        \only<3>{
          &(\Delta' : n \to \mathop{RCtx} m) \\
          &\times \left(\Delta_m \leq \sum_{x^\rho \in \Delta_n}\rho \cdot \Delta'_x\right)
        } \only<4>{
          &(\Delta' : \mathrm{Mat}~R~(m, n) \\
          &\times \left(\Delta_m \leq \Delta'\Delta_n\right)
        } \\
        &\times \left((x^\rho \in \Delta_n) \to \Delta'_x \vdash \typed \sigma~x\right)
      \end{flalign*}
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Resourced substitution example}
    \begin{itemize}
    \item
      \begin{flalign*}
        \Delta_m \Rightarrow_{\typed \sigma}^r \Delta_n :\equiv {}
        &(\Delta' : \mathrm{Mat}~R~(m, n) \\
        &\times \left(\Delta_m \leq \Delta'\Delta_n\right) \\
        &\times \left((x^\rho \in \Delta_n) \to \Delta'_x \vdash \typed \sigma~x\right)
      \end{flalign*}
    \item Variable rule
      \inferrule{\ctx{\Gamma}{\Delta} \leq \underline 0, \ctxvar{x}{S}{1}, \underline 0}
                {\ctx{\Gamma}{\Delta} \vdash x \in S}
    \item<2->
      $\mathrm{id}_\Delta :\equiv (\Delta', \mathit{prf}, \mathrm{var}) \quad
      \textrm{where}~\Delta'_x :\equiv \underline 0, x^1, \underline 0$
    \item<3-> $\mathit{prf}$ is $\Delta = I\Delta = \Delta'\Delta$
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Fundamental lemma, revisited}
    \begin{itemize}
    \item $\llbracket tt \rrbracket : \llbracket \Gamma \rrbracket \to
      \llbracket S \rrbracket$
    \item $\llbracket \ctx{\Gamma}{\Delta} \rrbracket^R : \mathcal{W} \to
      \llbracket \Gamma \rrbracket \times \llbracket \Gamma \rrbracket \to \Omega$
    \item $\forall w.~\forall(\gamma, \gamma') \in \llbracket \ctx{\Gamma}{\Delta}
      \rrbracket^R~w.~(\llbracket tt \rrbracket~\gamma, \llbracket tt
      \rrbracket~\gamma') \in \llbracket S \rrbracket^R~w$
    \item Consequences:
      \begin{itemize}
      \item Worlds are bags of keys, semiring counts usages \\
        $\implies$ the keys appearing in the context are a permutation of the
        keys appearing in the term
      \item Worlds specify maximum distance, semiring tracks distances \\
        $\implies$ the term is sensitive to changes in variables proportional to
        the annotations on those variables
      \item Worlds are trivial, semiring tracks polarity \\
        $\implies$ if assignments in the environment increase/decrease, the
        result follows suit
      \end{itemize}
    \end{itemize}
  \end{frame}
  \begin{frame}
    \frametitle{Conclusion}
    \begin{itemize}
    \item \url{https://github.com/laMudri/quantitative} \pause
    \item Abadi, Banerjee, Heintze 1999 -- A Core Calculus of Dependency
    \item Reed, Pierce 2010 -- Distance Makes the Types Grow Stronger
    \item Arntzenius 2018 -- Type inference for monotonicity \pause
    \item Staged computation?
    \item More problems?
    \end{itemize}
  \end{frame}
\end{document}
